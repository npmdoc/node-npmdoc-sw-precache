<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/googlechrome/sw-precache">sw-precache (v5.1.0)</a>
</h1>
<h4>Generates a service worker to cache your local App Shell resources.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.sw-precache">module sw-precache</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sw-precache.generate">
            function <span class="apidocSignatureSpan">sw-precache.</span>generate
            <span class="apidocSignatureSpan">(params, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sw-precache.write">
            function <span class="apidocSignatureSpan">sw-precache.</span>write
            <span class="apidocSignatureSpan">(filePath, params, callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sw-precache.</span>functions</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sw-precache.functions">module sw-precache.functions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sw-precache.functions.addDirectoryIndex">
            function <span class="apidocSignatureSpan">sw-precache.functions.</span>addDirectoryIndex
            <span class="apidocSignatureSpan">(originalUrl, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sw-precache.functions.cleanResponse">
            function <span class="apidocSignatureSpan">sw-precache.functions.</span>cleanResponse
            <span class="apidocSignatureSpan">(originalResponse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sw-precache.functions.createCacheKey">
            function <span class="apidocSignatureSpan">sw-precache.functions.</span>createCacheKey
            <span class="apidocSignatureSpan">(originalUrl, paramName, paramValue, dontCacheBustUrlsMatching)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sw-precache.functions.isPathWhitelisted">
            function <span class="apidocSignatureSpan">sw-precache.functions.</span>isPathWhitelisted
            <span class="apidocSignatureSpan">(whitelist, absoluteUrlString)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sw-precache.functions.stripIgnoredUrlParameters">
            function <span class="apidocSignatureSpan">sw-precache.functions.</span>stripIgnoredUrlParameters
            <span class="apidocSignatureSpan">(originalUrl, ignoreUrlParametersMatching)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sw-precache.generate">module sw-precache.generate</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sw-precache.generate.generate">
            function <span class="apidocSignatureSpan">sw-precache.</span>generate
            <span class="apidocSignatureSpan">(params, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sw-precache.write">module sw-precache.write</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sw-precache.write.write">
            function <span class="apidocSignatureSpan">sw-precache.</span>write
            <span class="apidocSignatureSpan">(filePath, params, callback)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sw-precache" id="apidoc.module.sw-precache">module sw-precache</a></h1>


    <h2>
        <a href="#apidoc.element.sw-precache.generate" id="apidoc.element.sw-precache.generate">
        function <span class="apidocSignatureSpan">sw-precache.</span>generate
        <span class="apidocSignatureSpan">(params, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generate(params, callback) {
  return new Promise(function(resolve, reject) {
    params = defaults(params || {}, {
      cacheId: '',
      clientsClaim: true,
      directoryIndex: 'index.html',
      dontCacheBustUrlsMatching: null,
      dynamicUrlToDependencies: {},
      handleFetch: true,
      ignoreUrlParametersMatching: [/^utm_/],
      importScripts: [],
      logger: console.log,
      maximumFileSizeToCacheInBytes: 2 * 1024 * 1024, // 2MB
      navigateFallback: '',
      navigateFallbackWhitelist: [],
      replacePrefix: '',
      skipWaiting: true,
      staticFileGlobs: [],
      stripPrefix: '',
      stripPrefixMulti: {},
      templateFilePath: path.join(
        path.dirname(fs.realpathSync(__filename)), '..', 'service-worker.tmpl'),
      verbose: false
    });

    if (!Array.isArray(params.ignoreUrlParametersMatching)) {
      params.ignoreUrlParametersMatching = [params.ignoreUrlParametersMatching];
    }

    var relativeUrlToHash = {};
    var cumulativeSize = 0;
    params.stripPrefixMulti[params.stripPrefix] = params.replacePrefix;

    params.staticFileGlobs.forEach(function(globPattern) {
      var filesAndSizesAndHashes = getFilesAndSizesAndHashesForGlobPattern(
        globPattern, params.outputFilePath);

      // The files returned from glob are sorted by default, so we don't need to sort here.
      filesAndSizesAndHashes.forEach(function(fileAndSizeAndHash) {
        if (fileAndSizeAndHash.size &lt;= params.maximumFileSizeToCacheInBytes) {
          // Strip the prefix to turn this into a relative URL.
          var relativeUrl = fileAndSizeAndHash.file
            .replace(
              new RegExp('^(' + Object.keys(params.stripPrefixMulti)
                  .map(escapeRegExp).join('|') + ')'),
              function(match) {
                return params.stripPrefixMulti[match];
              })
            .replace(path.sep, '/');
          relativeUrlToHash[relativeUrl] = fileAndSizeAndHash.hash;

          if (params.verbose) {
            params.logger(util.format('Caching static resource "%s" (%s)',
              fileAndSizeAndHash.file,
              prettyBytes(fileAndSizeAndHash.size)));
          }

          cumulativeSize += fileAndSizeAndHash.size;
        } else {
          params.logger(
            util.format('Skipping static resource "%s" (%s) - max size is %s',
            fileAndSizeAndHash.file, prettyBytes(fileAndSizeAndHash.size),
            prettyBytes(params.maximumFileSizeToCacheInBytes)));
        }
      });
    });

    Object.keys(params.dynamicUrlToDependencies).forEach(function(dynamicUrl) {
      var dependency = params.dynamicUrlToDependencies[dynamicUrl];
      var isString = typeof dependency === 'string';

      if (!Array.isArray(dependency) &amp;&amp; !isString) {
        throw Error(util.format(
          'The value for the dynamicUrlToDependencies.%s ' +
          'option must be an Array or a String.',
          dynamicUrl));
      }

      if (isString) {
        cumulativeSize += dependency.length;
        relativeUrlToHash[dynamicUrl] = getHash(dependency);
      } else {
        var filesAndSizesAndHashes = dependency
          .sort()
          .map(function(file) {
            try {
              return getFileAndSizeAndHashForFile(file);
            } catch (e) {
              // Provide some additional information about the failure if the file is missing.
              if (e.code === 'ENOENT') {
                params.logger(util.format(
                  '%s was listed as a dependency for dynamic URL %s, but ' +
                  'the file does not exist. Either remove the entry as a ' +
                  'dependency, or correct the path to the file.',
                  file, dynamicUrl
                ));
              }
              // Re-throw the exception unconditionally, since this should be treated as fatal.
              throw e;
            }
          });
        var concatenatedHashes = '';

        filesAndSizesAndHashes.forEach(function(fileAndSizeAndHash) {
          // Let's assume that the response size of a server-g ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sw-precache.write" id="apidoc.element.sw-precache.write">
        function <span class="apidocSignatureSpan">sw-precache.</span>write
        <span class="apidocSignatureSpan">(filePath, params, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write(filePath, params, callback) {
  return new Promise(function(resolve, reject) {
    function finish(error, value) {
      if (error) {
        reject(error);
      } else {
        resolve(value);
      }

      if (callback) {
        callback(error, value);
      }
    }

    mkdirp.sync(path.dirname(filePath));

    // Keep track of where we're outputting the file to ensure that we don't
    // pick up a previously written version in our new list of files.
    // See https://github.com/GoogleChrome/sw-precache/issues/101
    params.outputFilePath = absolutePath(filePath);

    generate(params).then(function(serviceWorkerFileContents) {
      fs.writeFile(filePath, serviceWorkerFileContents, finish);
    }, finish);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
gulp.task('generate-service-worker', function(callback) {
  var path = require('path');
  var swPrecache = require('sw-precache');
  var rootDir = 'app';

  swPrecache.<span class="apidocCodeKeywordSpan">write</span>(`${rootDir}/service-worker.js`, {
    staticFileGlobs: [rootDir + '/**/*.{js,html,css,png,jpg,gif,svg,eot,ttf,woff}'],
    stripPrefix: rootDir
  }, callback);
});
```

This task will create `app/service-worker.js`, which your client pages need to
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sw-precache.functions" id="apidoc.module.sw-precache.functions">module sw-precache.functions</a></h1>


    <h2>
        <a href="#apidoc.element.sw-precache.functions.addDirectoryIndex" id="apidoc.element.sw-precache.functions.addDirectoryIndex">
        function <span class="apidocSignatureSpan">sw-precache.functions.</span>addDirectoryIndex
        <span class="apidocSignatureSpan">(originalUrl, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addDirectoryIndex = function (originalUrl, index) {
  var url = new URL(originalUrl);
  if (url.pathname.slice(-1) === '/') {
    url.pathname += index;
  }
  return url.toString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sw-precache.functions.cleanResponse" id="apidoc.element.sw-precache.functions.cleanResponse">
        function <span class="apidocSignatureSpan">sw-precache.functions.</span>cleanResponse
        <span class="apidocSignatureSpan">(originalResponse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cleanResponse = function (originalResponse) {
  // If this is not a redirected response, then we don't have to do anything.
  if (!originalResponse.redirected) {
    return Promise.resolve(originalResponse);
  }

  // Firefox 50 and below doesn't support the Response.body stream, so we may
  // need to read the entire body to memory as a Blob.
  var bodyPromise = 'body' in originalResponse ?
    Promise.resolve(originalResponse.body) :
    originalResponse.blob();

  return bodyPromise.then(function(body) {
    // new Response() is happy when passed either a stream or a Blob.
    return new Response(body, {
      headers: originalResponse.headers,
      status: originalResponse.status,
      statusText: originalResponse.statusText
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sw-precache.functions.createCacheKey" id="apidoc.element.sw-precache.functions.createCacheKey">
        function <span class="apidocSignatureSpan">sw-precache.functions.</span>createCacheKey
        <span class="apidocSignatureSpan">(originalUrl, paramName, paramValue, dontCacheBustUrlsMatching)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createCacheKey = function (originalUrl, paramName, paramValue, dontCacheBustUrlsMatching) {
  // Create a new URL object to avoid modifying originalUrl.
  var url = new URL(originalUrl);

  // If dontCacheBustUrlsMatching is not set, or if we don't have a match,
  // then add in the extra cache-busting URL parameter.
  if (!dontCacheBustUrlsMatching ||
      !(url.pathname.match(dontCacheBustUrlsMatching))) {
    url.search += (url.search ? '&amp;' : '') +
      encodeURIComponent(paramName) + '=' + encodeURIComponent(paramValue);
  }

  return url.toString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sw-precache.functions.isPathWhitelisted" id="apidoc.element.sw-precache.functions.isPathWhitelisted">
        function <span class="apidocSignatureSpan">sw-precache.functions.</span>isPathWhitelisted
        <span class="apidocSignatureSpan">(whitelist, absoluteUrlString)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isPathWhitelisted = function (whitelist, absoluteUrlString) {
  // If the whitelist is empty, then consider all URLs to be whitelisted.
  if (whitelist.length === 0) {
    return true;
  }

  // Otherwise compare each path regex to the path of the URL passed in.
  var path = (new URL(absoluteUrlString)).pathname;
  return whitelist.some(function(whitelistedPathRegex) {
    return path.match(whitelistedPathRegex);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sw-precache.functions.stripIgnoredUrlParameters" id="apidoc.element.sw-precache.functions.stripIgnoredUrlParameters">
        function <span class="apidocSignatureSpan">sw-precache.functions.</span>stripIgnoredUrlParameters
        <span class="apidocSignatureSpan">(originalUrl, ignoreUrlParametersMatching)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stripIgnoredUrlParameters = function (originalUrl, ignoreUrlParametersMatching) {
  var url = new URL(originalUrl);

  url.search = url.search.slice(1) // Exclude initial '?'
    .split('&amp;') // Split into an array of 'key=value' strings
    .map(function(kv) {
      return kv.split('='); // Split each 'key=value' string into a [key, value] array
    })
    .filter(function(kv) {
      return ignoreUrlParametersMatching.every(function(ignoredRegex) {
        return !ignoredRegex.test(kv[0]); // Return true iff the key doesn't match any of the regexes.
      });
    })
    .map(function(kv) {
      return kv.join('='); // Join each [key, value] array into a 'key=value' string
    })
    .join('&amp;'); // Join the array of 'key=value' strings into a string with '&amp;' in between each

  return url.toString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sw-precache.generate" id="apidoc.module.sw-precache.generate">module sw-precache.generate</a></h1>


    <h2>
        <a href="#apidoc.element.sw-precache.generate.generate" id="apidoc.element.sw-precache.generate.generate">
        function <span class="apidocSignatureSpan">sw-precache.</span>generate
        <span class="apidocSignatureSpan">(params, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generate(params, callback) {
  return new Promise(function(resolve, reject) {
    params = defaults(params || {}, {
      cacheId: '',
      clientsClaim: true,
      directoryIndex: 'index.html',
      dontCacheBustUrlsMatching: null,
      dynamicUrlToDependencies: {},
      handleFetch: true,
      ignoreUrlParametersMatching: [/^utm_/],
      importScripts: [],
      logger: console.log,
      maximumFileSizeToCacheInBytes: 2 * 1024 * 1024, // 2MB
      navigateFallback: '',
      navigateFallbackWhitelist: [],
      replacePrefix: '',
      skipWaiting: true,
      staticFileGlobs: [],
      stripPrefix: '',
      stripPrefixMulti: {},
      templateFilePath: path.join(
        path.dirname(fs.realpathSync(__filename)), '..', 'service-worker.tmpl'),
      verbose: false
    });

    if (!Array.isArray(params.ignoreUrlParametersMatching)) {
      params.ignoreUrlParametersMatching = [params.ignoreUrlParametersMatching];
    }

    var relativeUrlToHash = {};
    var cumulativeSize = 0;
    params.stripPrefixMulti[params.stripPrefix] = params.replacePrefix;

    params.staticFileGlobs.forEach(function(globPattern) {
      var filesAndSizesAndHashes = getFilesAndSizesAndHashesForGlobPattern(
        globPattern, params.outputFilePath);

      // The files returned from glob are sorted by default, so we don't need to sort here.
      filesAndSizesAndHashes.forEach(function(fileAndSizeAndHash) {
        if (fileAndSizeAndHash.size &lt;= params.maximumFileSizeToCacheInBytes) {
          // Strip the prefix to turn this into a relative URL.
          var relativeUrl = fileAndSizeAndHash.file
            .replace(
              new RegExp('^(' + Object.keys(params.stripPrefixMulti)
                  .map(escapeRegExp).join('|') + ')'),
              function(match) {
                return params.stripPrefixMulti[match];
              })
            .replace(path.sep, '/');
          relativeUrlToHash[relativeUrl] = fileAndSizeAndHash.hash;

          if (params.verbose) {
            params.logger(util.format('Caching static resource "%s" (%s)',
              fileAndSizeAndHash.file,
              prettyBytes(fileAndSizeAndHash.size)));
          }

          cumulativeSize += fileAndSizeAndHash.size;
        } else {
          params.logger(
            util.format('Skipping static resource "%s" (%s) - max size is %s',
            fileAndSizeAndHash.file, prettyBytes(fileAndSizeAndHash.size),
            prettyBytes(params.maximumFileSizeToCacheInBytes)));
        }
      });
    });

    Object.keys(params.dynamicUrlToDependencies).forEach(function(dynamicUrl) {
      var dependency = params.dynamicUrlToDependencies[dynamicUrl];
      var isString = typeof dependency === 'string';

      if (!Array.isArray(dependency) &amp;&amp; !isString) {
        throw Error(util.format(
          'The value for the dynamicUrlToDependencies.%s ' +
          'option must be an Array or a String.',
          dynamicUrl));
      }

      if (isString) {
        cumulativeSize += dependency.length;
        relativeUrlToHash[dynamicUrl] = getHash(dependency);
      } else {
        var filesAndSizesAndHashes = dependency
          .sort()
          .map(function(file) {
            try {
              return getFileAndSizeAndHashForFile(file);
            } catch (e) {
              // Provide some additional information about the failure if the file is missing.
              if (e.code === 'ENOENT') {
                params.logger(util.format(
                  '%s was listed as a dependency for dynamic URL %s, but ' +
                  'the file does not exist. Either remove the entry as a ' +
                  'dependency, or correct the path to the file.',
                  file, dynamicUrl
                ));
              }
              // Re-throw the exception unconditionally, since this should be treated as fatal.
              throw e;
            }
          });
        var concatenatedHashes = '';

        filesAndSizesAndHashes.forEach(function(fileAndSizeAndHash) {
          // Let's assume that the response size of a server-g ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sw-precache.write" id="apidoc.module.sw-precache.write">module sw-precache.write</a></h1>


    <h2>
        <a href="#apidoc.element.sw-precache.write.write" id="apidoc.element.sw-precache.write.write">
        function <span class="apidocSignatureSpan">sw-precache.</span>write
        <span class="apidocSignatureSpan">(filePath, params, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write(filePath, params, callback) {
  return new Promise(function(resolve, reject) {
    function finish(error, value) {
      if (error) {
        reject(error);
      } else {
        resolve(value);
      }

      if (callback) {
        callback(error, value);
      }
    }

    mkdirp.sync(path.dirname(filePath));

    // Keep track of where we're outputting the file to ensure that we don't
    // pick up a previously written version in our new list of files.
    // See https://github.com/GoogleChrome/sw-precache/issues/101
    params.outputFilePath = absolutePath(filePath);

    generate(params).then(function(serviceWorkerFileContents) {
      fs.writeFile(filePath, serviceWorkerFileContents, finish);
    }, finish);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
gulp.task('generate-service-worker', function(callback) {
  var path = require('path');
  var swPrecache = require('sw-precache');
  var rootDir = 'app';

  swPrecache.<span class="apidocCodeKeywordSpan">write</span>(`${rootDir}/service-worker.js`, {
    staticFileGlobs: [rootDir + '/**/*.{js,html,css,png,jpg,gif,svg,eot,ttf,woff}'],
    stripPrefix: rootDir
  }, callback);
});
```

This task will create `app/service-worker.js`, which your client pages need to
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>